<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ph√¢n T√≠ch Giao Thoa √Ånh S√°ng N√¢ng Cao</title>
    <!-- T·∫£i Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Thi·∫øt l·∫≠p c·∫•u h√¨nh Tailwind -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#059669', /* Xanh l√° c√¢y ƒë·∫≠m m·ªõi */
                        'secondary': '#10b981',
                        'dark-bg': '#0f172a',
                        'light-text': '#f1f5f9',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
        }
        .container-card {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        input[type=range] {
            width: 100%;
        }
        .simulation-area {
            background-color: #0f172a; /* N·ªÅn t·ªëi cho m√†n quan s√°t */
            border-radius: 0.75rem;
            border: 1px solid #1e293b;
            min-height: 400px; /* ƒê·∫£m b·∫£o chi·ªÅu cao ƒë·ªß */
        }
    </style>
</head>
<body class="p-4 sm:p-8 bg-gray-50 min-h-screen">
    <a href="index.html" class="fixed top-4 left-4 z-50 p-3 bg-blue-600 text-white rounded-lg shadow-xl hover:bg-blue-700 transition duration-300 flex items-center space-x-2">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
        <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z" />
    </svg>
    <span class="font-semibold hidden sm:inline">Quay v·ªÅ Trang Ch·ªß</span>
    </a>

    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-900 mb-6 translate-y-0 text-center">
            üî¨ Ph√¢n T√≠ch Giao Thoa √Ånh S√°ng (Khe Young)
        </h1>
        <p class="text-center text-gray-600 mb-8">
            ƒêi·ªÅu ch·ªânh c√°c th√¥ng s·ªë v√† ch·ªçn ch·∫ø ƒë·ªô ph√¢n t√≠ch ƒë·ªÉ xem s·ª± thay ƒë·ªïi c·ªßa m·∫´u h√¨nh giao thoa.
        </p>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            
            <!-- Khu v·ª±c ƒëi·ªÅu khi·ªÉn (Inputs) -->
            <div class="lg:col-span-1 bg-white p-6 rounded-xl container-card shadow-lg flex flex-col">
                <h2 class="text-2xl font-semibold text-primary mb-5">‚öôÔ∏è ƒêi·ªÅu Khi·ªÉn & Ch·∫ø ƒê·ªô</h2>
                
                <!-- CH·ªåN CH·∫æ ƒê·ªò PH√ÇN T√çCH -->
                <div class="mb-6 p-3 bg-gray-100 rounded-lg">
                    <h3 class="text-base font-semibold text-gray-800 mb-2">Ch·∫ø ƒë·ªô Ph√¢n t√≠ch</h3>
                    <div class="flex flex-wrap gap-2">
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="radio" name="mode" value="single" checked onchange="updateMode()" class="form-radio text-primary">
                            <span class="text-sm">ƒê∆°n s·∫Øc ($\lambda_1$)</span>
                        </label>
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="radio" name="mode" value="two_colors" onchange="updateMode()" class="form-radio text-primary">
                            <span class="text-sm">Hai m√†u ($\lambda_1, \lambda_2$)</span>
                        </label>
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="radio" name="mode" value="white_light" onchange="updateMode()" class="form-radio text-primary">
                            <span class="text-sm">√Ånh s√°ng Tr·∫Øng</span>
                        </label>
                    </div>
                </div>

                <!-- Input 1: B∆∞·ªõc s√≥ng (lambda 1) -->
                <div class="mb-6" id="lambda1_group">
                    <label for="lambda1" class="block text-sm font-medium text-gray-700">
                        B∆∞·ªõc s√≥ng 1 (Œª‚ÇÅ): <span id="lambda1Value" class="font-bold text-lg text-primary">600</span> nm
                    </label>
                    <input type="range" id="lambda1" min="400" max="750" value="600" step="5"
                           oninput="updateInputs()"
                           class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <div class="flex justify-between text-xs text-gray-500 mt-1"><span>400 nm (T√≠m)</span><span>750 nm (ƒê·ªè)</span></div>
                </div>

                <!-- Input 2: B∆∞·ªõc s√≥ng (lambda 2) - Ch·ªâ hi·ªán khi ch·∫ø ƒë·ªô two_colors -->
                <div class="mb-6 hidden" id="lambda2_group">
                    <label for="lambda2" class="block text-sm font-medium text-gray-700">
                        B∆∞·ªõc s√≥ng 2 (Œª‚ÇÇ): <span id="lambda2Value" class="font-bold text-lg text-primary">450</span> nm
                    </label>
                    <input type="range" id="lambda2" min="400" max="750" value="450" step="5"
                           oninput="updateInputs()"
                           class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <div class="flex justify-between text-xs text-gray-500 mt-1"><span>400 nm (T√≠m)</span><span>750 nm (ƒê·ªè)</span></div>
                </div>

                <!-- Input 3: Kho·∫£ng c√°ch hai khe (a) -->
                <div class="mb-6">
                    <label for="a" class="block text-sm font-medium text-gray-700">
                        Kho·∫£ng c√°ch hai khe (a): <span id="aValue" class="font-bold text-lg text-primary">0.5</span> mm
                    </label>
                    <input type="range" id="a" min="0.1" max="2.0" value="0.5" step="0.05"
                           oninput="updateInputs()"
                           class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <div class="flex justify-between text-xs text-gray-500 mt-1"><span>0.1 mm</span><span>2.0 mm</span></div>
                </div>

                <!-- Input 4: Kho·∫£ng c√°ch ƒë·∫øn m√†n (D) -->
                <div class="mb-6">
                    <label for="D" class="block text-sm font-medium text-gray-700">
                        Kho·∫£ng c√°ch ƒë·∫øn m√†n (D): <span id="DValue" class="font-bold text-lg text-primary">2.0</span> m
                    </label>
                    <input type="range" id="D" min="0.5" max="5.0" value="2.0" step="0.1"
                           oninput="updateInputs()"
                           class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <div class="flex justify-between text-xs text-gray-500 mt-1"><span>0.5 m</span><span>5.0 m</span></div>
                </div>
            </div>

            <!-- Khu v·ª±c k·∫øt qu·∫£ v√† m√¥ ph·ªèng -->
            <div class="lg:col-span-2 flex flex-col gap-8">
                
                <!-- Khu v·ª±c k·∫øt qu·∫£ t√≠nh to√°n -->
                <div class="bg-primary text-white p-4 rounded-xl shadow-lg">
                    <h3 class="text-xl font-bold mb-2">üìä K·∫øt Qu·∫£ Ph√¢n T√≠ch</h3>
                    <div id="results_single" class="p-1">
                        <p class="text-sm">
                            Kho·∫£ng v√¢n (i‚ÇÅ): <span id="fringeSpacing1" class="text-2xl font-extrabold ml-2">...</span> mm
                        </p>
                    </div>
                    <div id="results_two_colors" class="hidden p-1">
                        <p class="text-sm">
                            Kho·∫£ng v√¢n i‚ÇÅ: <span id="fringeSpacing1_two" class="text-lg font-bold ml-1">...</span> mm
                            (Œª‚ÇÅ)
                        </p>
                        <p class="text-sm">
                            Kho·∫£ng v√¢n i‚ÇÇ: <span id="fringeSpacing2_two" class="text-lg font-bold ml-1">...</span> mm
                            (Œª‚ÇÇ)
                        </p>
                        <p class="text-sm mt-3 border-t border-white/50 pt-2">
                            Kho·∫£ng c√°ch V√¢n tr√πng (i_tr√πng): <span id="lcmFringeSpacing" class="text-2xl font-extrabold ml-2">...</span> mm
                        </p>
                    </div>
                    <div id="results_white_light" class="hidden p-1">
                         <p class="text-sm">
                            V√¢n trung t√¢m l√† v√¢n s√°ng <span class="font-bold text-white bg-black/30 px-1 rounded">M√†u Tr·∫Øng</span>.
                        </p>
                        <p class="text-sm">
                            V√¢n b·∫≠c cao l√† c√°c d·∫£i quang ph·ªï, c√†ng xa v√¢n trung t√¢m s·ª± ch·ªìng ch·∫≠p c√†ng l·ªõn.
                        </p>
                    </div>
                    <p class="text-xs mt-3 opacity-80 border-t border-white/50 pt-2">
                        C√¥ng th·ª©c c∆° b·∫£n: $i = \frac{\lambda D}{a}$
                    </p>
                </div>
                
                <!-- Khu v·ª±c m√¥ ph·ªèng (Canvas) -->
                <div class="bg-white p-4 rounded-xl container-card shadow-lg flex flex-col flex-grow">
                    <h2 class="text-2xl font-semibold text-primary mb-3">üåå M·∫´u H√¨nh Giao Thoa</h2>
                    <div class="simulation-area flex-grow overflow-hidden relative">
                        <canvas id="interferenceCanvas" class="w-full h-full"></canvas>
                        <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
                            <span class="text-white text-opacity-30 text-xs transform -rotate-90">M√ÄN QUAN S√ÅT</span>
                            <span class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-black/50 text-white px-2 py-1 rounded-full text-xs">V√¢n Trung T√¢m (k=0)</span>
                        </div>
                    </div>
                    <p class="text-center text-xs text-gray-500 mt-2">
                        M√¥ ph·ªèng tr·ª±c quan m·∫´u h√¨nh giao thoa tr√™n m√†n ch·∫Øn (hi·ªÉn th·ªã 10 mm v·∫≠t l√Ω ·ªü trung t√¢m).
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Tham Chi·∫øu DOM & H·∫±ng S·ªë ---
        const lambda1Input = document.getElementById('lambda1');
        const lambda2Input = document.getElementById('lambda2');
        const aInput = document.getElementById('a');
        const DInput = document.getElementById('D');
        
        const lambda1ValueSpan = document.getElementById('lambda1Value');
        const lambda2ValueSpan = document.getElementById('lambda2Value');
        const aValueSpan = document.getElementById('aValue');
        const DValueSpan = document.getElementById('DValue');
        
        const lambda1Group = document.getElementById('lambda1_group');
        const lambda2Group = document.getElementById('lambda2_group');

        const resultsSingle = document.getElementById('results_single');
        const resultsTwoColors = document.getElementById('results_two_colors');
        const resultsWhiteLight = document.getElementById('results_white_light');

        const fringeSpacing1Span = document.getElementById('fringeSpacing1');
        const fringeSpacing1TwoSpan = document.getElementById('fringeSpacing1_two');
        const fringeSpacing2TwoSpan = document.getElementById('fringeSpacing2_two');
        const lcmFringeSpacingSpan = document.getElementById('lcmFringeSpacing');
        
        const canvas = document.getElementById('interferenceCanvas');
        const ctx = canvas.getContext('2d');
        
        const VISIBLE_HEIGHT_MM = 10; // Gi·∫£ s·ª≠ canvas hi·ªÉn th·ªã 10 mm v·∫≠t l√Ω ·ªü trung t√¢m
        const WHITE_LIGHT_STEPS = [420, 480, 550, 600, 650, 700]; // ƒê·∫°i di·ªán cho 6 b∆∞·ªõc s√≥ng ch√≠nh

        let currentMode = 'single';

        // --- H√†m To√°n H·ªçc ---
        
        // Greatest Common Divisor (∆Ø·ªõc chung l·ªõn nh·∫•t)
        function gcd(a, b) {
            return b ? gcd(b, a % b) : a;
        }

        // Least Common Multiple (B·ªôi chung nh·ªè nh·∫•t)
        function lcm(a, b) {
            return (a * b) / gcd(a, b);
        }

        // --- Chuy·ªÉn ƒë·ªïi B∆∞·ªõc s√≥ng sang M√†u RGB (D·ª±a tr√™n h√†m c≈©) ---
        function wavelengthToColor(wavelength) {
            let R, G, B;
            const gamma = 0.8;
            
            if (wavelength >= 380 && wavelength < 440) {
                R = -(wavelength - 440) / (440 - 380); G = 0.0; B = 1.0;
            } else if (wavelength >= 440 && wavelength < 490) {
                R = 0.0; G = (wavelength - 440) / (490 - 440); B = 1.0;
            } else if (wavelength >= 490 && wavelength < 510) {
                R = 0.0; G = 1.0; B = -(wavelength - 510) / (510 - 490);
            } else if (wavelength >= 510 && wavelength < 580) {
                R = (wavelength - 510) / (580 - 510); G = 1.0; B = 0.0;
            } else if (wavelength >= 580 && wavelength < 645) {
                R = 1.0; G = -(wavelength - 645) / (645 - 580); B = 0.0;
            } else if (wavelength >= 645 && wavelength <= 750) {
                R = 1.0; G = 0.0; B = 0.0;
            } else {
                R = 0.0; G = 0.0; B = 0.0;
            }

            let S = 1.0;
            if (wavelength > 700) S = 0.3 + 0.7 * (750 - wavelength) / (750 - 700);
            else if (wavelength < 420) S = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);

            R = Math.pow(R * S, gamma) * 255;
            G = Math.pow(G * S, gamma) * 255;
            B = Math.pow(B * S, gamma) * 255;

            return { r: Math.round(R), g: Math.round(G), b: Math.round(B) };
        }
        
        // --- H√†m T√≠nh Kho·∫£ng V√¢n ---
        function calculateFringeSpacing(lambda_nm, D_m, a_mm) {
            // i (mm) = (lambda (nm) / 1000) * D (m) / a (mm)
            return (lambda_nm / 1000) * D_m / a_mm;
        }

        // --- C·∫≠p nh·∫≠t UI theo ch·∫ø ƒë·ªô ---
        function updateMode() {
            currentMode = document.querySelector('input[name="mode"]:checked').value;
            
            // ·∫®n/Hi·ªán inputs Œª‚ÇÇ
            if (currentMode === 'two_colors') {
                lambda2Group.classList.remove('hidden');
            } else {
                lambda2Group.classList.add('hidden');
            }

            // ·∫®n/Hi·ªán khu v·ª±c k·∫øt qu·∫£
            resultsSingle.classList.toggle('hidden', currentMode !== 'single');
            resultsTwoColors.classList.toggle('hidden', currentMode !== 'two_colors');
            resultsWhiteLight.classList.toggle('hidden', currentMode !== 'white_light');
            
            updateInputs();
        }

        // --- T√≠nh to√°n v√† M√¥ ph·ªèng (H√†m ch√≠nh) ---
        function updateInputs() {
            // C·∫≠p nh·∫≠t gi√° tr·ªã hi·ªÉn th·ªã b√™n c·∫°nh slider
            lambda1ValueSpan.textContent = lambda1Input.value;
            aValueSpan.textContent = aInput.value;
            DValueSpan.textContent = DInput.value;
            if (currentMode === 'two_colors') {
                lambda2ValueSpan.textContent = lambda2Input.value;
            }

            // L·∫•y gi√° tr·ªã c·ªë ƒë·ªãnh
            const a_mm = parseFloat(aInput.value);
            const D_m = parseFloat(DInput.value);

            // T√≠nh to√°n kho·∫£ng v√¢n d·ª±a tr√™n ch·∫ø ƒë·ªô
            let i1_mm, i2_mm;
            
            if (currentMode === 'single' || currentMode === 'two_colors') {
                const lambda1_nm = parseFloat(lambda1Input.value);
                i1_mm = calculateFringeSpacing(lambda1_nm, D_m, a_mm);
                
                // C·∫≠p nh·∫≠t k·∫øt qu·∫£ ƒë∆°n s·∫Øc
                fringeSpacing1Span.textContent = i1_mm.toFixed(3);
                fringeSpacing1Span.style.color = `rgb(${wavelengthToColor(lambda1_nm).r}, ${wavelengthToColor(lambda1_nm).g}, ${wavelengthToColor(lambda1_nm).b})`;

                if (currentMode === 'two_colors') {
                    const lambda2_nm = parseFloat(lambda2Input.value);
                    i2_mm = calculateFringeSpacing(lambda2_nm, D_m, a_mm);
                    
                    // C·∫≠p nh·∫≠t k·∫øt qu·∫£ hai m√†u
                    fringeSpacing1TwoSpan.textContent = i1_mm.toFixed(3);
                    fringeSpacing2TwoSpan.textContent = i2_mm.toFixed(3);
                    fringeSpacing1TwoSpan.style.color = `rgb(${wavelengthToColor(lambda1_nm).r}, ${wavelengthToColor(lambda1_nm).g}, ${wavelengthToColor(lambda1_nm).b})`;
                    fringeSpacing2TwoSpan.style.color = `rgb(${wavelengthToColor(lambda2_nm).r}, ${wavelengthToColor(lambda2_nm).g}, ${wavelengthToColor(lambda2_nm).b})`;

                    // T√≠nh kho·∫£ng v√¢n tr√πng (i_tr√πng)
                    // Ta c√≥ k1*i1 = k2*i2 => k1/k2 = i2/i1
                    // i_tr√πng = B·ªôi chung nh·ªè nh·∫•t c·ªßa i1 v√† i2. Do i l√† s·ªë th·ª±c, ta ph·∫£i l√†m vi·ªác v·ªõi t·ªâ s·ªë nguy√™n.
                    // L·∫•y t·ªâ s·ªë b∆∞·ªõc s√≥ng: lambda1 / lambda2 = m/n (ph√¢n s·ªë t·ªëi gi·∫£n)
                    // V√¢n tr√πng: x = k * i_tr√πng = k * m * i2 = k * n * i1
                    
                    // S·ª≠ d·ª•ng b·ªôi chung nh·ªè nh·∫•t c·ªßa b∆∞·ªõc s√≥ng ƒë·ªÉ t√≠nh i_tr√πng
                    const lambda1_int = Math.round(lambda1_nm / 5); // ƒê∆∞a v·ªÅ s·ªë nguy√™n g·∫ßn nh·∫•t (chia cho 5 ƒë·ªÉ gi·∫£m ƒë·ªô l·ªõn)
                    const lambda2_int = Math.round(lambda2_nm / 5);
                    const i_trung_lcm = lcm(lambda1_int, lambda2_int);
                    
                    // i_tr√πng th·ª±c t·∫ø: i_tr√πng = i1 * (i_trung_lcm / lambda1_int)
                    const i_trung_mm = i1_mm * (i_trung_lcm / lambda1_int);

                    lcmFringeSpacingSpan.textContent = isFinite(i_trung_mm) ? i_trung_mm.toFixed(3) : "Kh√¥ng x√°c ƒë·ªãnh";
                    lcmFringeSpacingSpan.style.color = 'white'; // V√¢n tr√πng lu√¥n l√† tr·∫Øng (t·ªïng h·ª£p)
                }
            }
            
            // CH·ªñ S·ª¨A L·ªñI: Truy·ªÅn a_mm v√† D_m v√†o drawPattern
            drawPattern(currentMode, i1_mm, i2_mm, a_mm, D_m);
        }

        // --- H√†m V·∫Ω M·∫´u H√¨nh Giao Thoa ---
        // CH·ªñ S·ª¨A L·ªñI: ƒê·ªãnh nghƒ©a h√†m nh·∫≠n a_mm v√† D_m
        function drawPattern(mode, i1_mm, i2_mm, a_mm, D_m) {
            // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc canvas
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            const W = canvas.width;
            const H = canvas.height;
            const centerY = H / 2;
            
            // X√≥a canvas
            ctx.fillStyle = '#0f172a'; // N·ªÅn t·ªëi
            ctx.fillRect(0, 0, W, H);

            // T·ªâ l·ªá (Scale factor: mm -> pixel)
            const scale = H / VISIBLE_HEIGHT_MM;

            // L·∫•y gi√° tr·ªã ƒë·∫ßu v√†o
            const lambda1_nm = parseFloat(lambda1Input.value);
            const lambda2_nm = parseFloat(lambda2Input.value);

            // Duy·ªát qua t·ª´ng h√†ng pixel (t·ªça ƒë·ªô y) tr√™n canvas
            for (let y = 0; y < H; y++) {
                // y_from_center_mm: Kho·∫£ng c√°ch v·∫≠t l√Ω (mm) t·ª´ v√¢n trung t√¢m (y=centerY)
                const y_from_center_mm = (y - centerY) / scale;
                
                let totalR = 0;
                let totalG = 0;
                let totalB = 0;
                let totalIntensity = 0;

                // --- 1. Ch·∫ø ƒë·ªô √Ånh s√°ng ƒê∆°n s·∫Øc ---
                if (mode === 'single') {
                    const color = wavelengthToColor(lambda1_nm);

                    // k_prime: T·ªça ƒë·ªô theo kho·∫£ng v√¢n (y/i)
                    const k_prime = y_from_center_mm / i1_mm; 
                    
                    // T√≠nh c∆∞·ªùng ƒë·ªô theo c√¥ng th·ª©c Cos^2 (I = I_max * cos^2(pi * k_prime))
                    const phase = Math.PI * k_prime;
                    const intensity = Math.pow(Math.cos(phase), 2); 

                    totalR = color.r * intensity;
                    totalG = color.g * intensity;
                    totalB = color.b * intensity;
                    totalIntensity = intensity;

                } 
                // --- 2. Ch·∫ø ƒë·ªô Hai √Ånh s√°ng ƒê∆°n s·∫Øc ---
                else if (mode === 'two_colors') {
                    const color1 = wavelengthToColor(lambda1_nm);
                    const color2 = wavelengthToColor(lambda2_nm);

                    // C∆∞·ªùng ƒë·ªô I‚ÇÅ
                    const k_prime1 = y_from_center_mm / i1_mm; 
                    const phase1 = Math.PI * k_prime1;
                    const intensity1 = Math.pow(Math.cos(phase1), 2); 
                    
                    // C∆∞·ªùng ƒë·ªô I‚ÇÇ
                    const k_prime2 = y_from_center_mm / i2_mm; 
                    const phase2 = Math.PI * k_prime2;
                    const intensity2 = Math.pow(Math.cos(phase2), 2); 

                    // T·ªïng c∆∞·ªùng ƒë·ªô (Additive combination)
                    totalR = color1.r * intensity1 + color2.r * intensity2;
                    totalG = color1.g * intensity1 + color2.g * intensity2;
                    totalB = color1.b * intensity1 + color2.b * intensity2;
                    totalIntensity = intensity1 + intensity2;
                }
                // --- 3. Ch·∫ø ƒë·ªô √Ånh s√°ng Tr·∫Øng ---
                else if (mode === 'white_light') {
                    // T√≠nh t·ªïng ƒë√≥ng g√≥p c·ªßa m·ªôt s·ªë b∆∞·ªõc s√≥ng ƒë·∫°i di·ªán
                    WHITE_LIGHT_STEPS.forEach(lambda_step => {
                        // S·ª¨ D·ª§NG D_m v√† a_mm ƒë√£ ƒë∆∞·ª£c truy·ªÅn v√†o
                        const i_step_mm = calculateFringeSpacing(lambda_step, D_m, a_mm);
                        const color_step = wavelengthToColor(lambda_step);
                        
                        const k_prime_step = y_from_center_mm / i_step_mm;
                        const phase_step = Math.PI * k_prime_step;
                        const intensity_step = Math.pow(Math.cos(phase_step), 2);

                        totalR += color_step.r * intensity_step;
                        totalG += color_step.g * intensity_step;
                        totalB += color_step.b * intensity_step;
                        totalIntensity += intensity_step;
                    });
                }
                
                // Chu·∫©n h√≥a v√† v·∫Ω m√†u
                if (totalIntensity > 0) {
                    // Chu·∫©n h√≥a c∆∞·ªùng ƒë·ªô theo s·ªë l∆∞·ª£ng ngu·ªìn ho·∫∑c b∆∞·ªõc s√≥ng ƒë·∫°i di·ªán (cho m√†u s·∫Øc ch√≠nh x√°c)
                    let normalizer = (mode === 'single') ? 255 : (mode === 'two_colors' ? 510 : (WHITE_LIGHT_STEPS.length * 255)); 
                    
                    let finalR = Math.min(255, totalR * 255 / normalizer);
                    let finalG = Math.min(255, totalG * 255 / normalizer);
                    let finalB = Math.min(255, totalB * 255 / normalizer);

                    ctx.fillStyle = `rgb(${Math.round(finalR)}, ${Math.round(finalG)}, ${Math.round(finalB)})`;
                } else {
                    ctx.fillStyle = '#0f172a'; // V√¢n t·ªëi tuy·ªát ƒë·ªëi
                }

                ctx.globalAlpha = 1.0; 
                ctx.fillRect(0, y, W, 1); // V·∫Ω m·ªôt h√†ng pixel
            }
        }

        // ƒê·∫£m b·∫£o canvas ƒë∆∞·ª£c v·∫Ω l·∫°i khi c·ª≠a s·ªï tr√¨nh duy·ªát thay ƒë·ªïi k√≠ch th∆∞·ªõc
        window.addEventListener('resize', updateInputs);

        // Kh·ªüi t·∫°o ·ª©ng d·ª•ng khi t·∫£i trang
        window.onload = function() {
            // ƒê·∫∑t k√≠ch th∆∞·ªõc ban ƒë·∫ßu cho canvas
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // Kh·ªüi t·∫°o ch·∫ø ƒë·ªô v√† ch·∫°y l·∫ßn ƒë·∫ßu ti√™n
            updateMode();
        };

    </script>

</body>
</html>