<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√¥ Ph·ªèng S·ª± Chuy·ªÉn Th·ªÉ - V·∫≠t L√Ω ·∫£o 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="./tailwind-config.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link rel="stylesheet" href="../css/global.css">
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        #simulationCanvas {
            width: 100%;
            height: 100vh;
            display: block;
            outline: none;
        }

        .ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 0;
            /* Removing padding from container to handle header */
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 380px;
            max-height: 90vh;
            overflow: hidden;
            /* Needed for structure */
            resize: both;
            /* Resizable */
            min-width: 300px;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            transition: opacity 0.3s ease;
            z-index: 50;
        }

        .panel-header {
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.05);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            cursor: move;
            /* Drag handle */
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .panel-content {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }

        .dark .ui-panel {
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid #334155;
            color: white;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .dark .panel-header {
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        #btnShowPanel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 40;
            display: none;
            /* Hidden by default */
        }

        /* Hand Gesture UI */
        #webcam-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            border: 2px solid rgba(6, 182, 212, 0.5);
            z-index: 50;
            transform: scaleX(-1);
            object-fit: cover;
            opacity: 0.8;
            transition: all 0.3s ease;
        }

        #webcam-feed.active {
            border-color: #06b6d4;
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.5);
            opacity: 1;
        }

        .gesture-guide {
            position: absolute;
            bottom: 150px;
            right: 20px;
            background: rgba(15, 23, 42, 0.9);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 12px;
            z-index: 50;
            width: 200px;
            backdrop-filter: blur(8px);
        }

        .gesture-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .gesture-item:last-child {
            margin-bottom: 0;
        }

        .gesture-icon {
            font-size: 18px;
            width: 20px;
            text-align: center;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: #64748b;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }

        .status-dot.active {
            background: #06b6d4;
            box-shadow: 0 0 8px #06b6d4;
        }
    </style>
</head>

<body class="overflow-hidden m-0 p-0 bg-slate-900 text-white">

    <!-- Theme Toggle Removed: Forced Dark Mode -->

    <!-- 3D Canvas -->
    <div id="simulationCanvas"></div>

    <!-- Show Panel Button -->
    <button id="btnShowPanel" onclick="togglePanel(true)"
        class="bg-lab-cyan dark:bg-lab-dark_cyan hover:bg-cyan-600 text-white p-3 rounded-full shadow-lg transition-transform hover:scale-110">
        <i data-lucide="settings-2"></i>
    </button>

    <!-- Interactive Controls -->
    <div class="ui-panel" id="mainPanel">
        <!-- Drag Handle Header -->
        <div class="panel-header" id="panelHeader">
            <h1
                class="text-lg font-bold font-tech uppercase tracking-wider text-slate-800 dark:text-white flex items-center gap-2">
                <i data-lucide="flask-conical" class="text-lab-cyan dark:text-lab-dark_cyan w-5 h-5"></i> Ph√¢n T√≠ch
            </h1>
            <div class="flex items-center gap-2">
                <div class="text-xs font-mono px-2 py-0.5 bg-slate-100 dark:bg-slate-700 rounded text-slate-500 dark:text-slate-300 font-bold"
                    id="state-label">SOLID</div>
                <button onclick="togglePanel(false)" class="text-slate-400 hover:text-white"><i data-lucide="minus"
                        class="w-5 h-5"></i></button>
            </div>
        </div>

        <!-- Content -->
        <div class="panel-content">

            <!-- Material Selection -->
            <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-xs font-semibold mb-1 text-slate-500 dark:text-slate-400">Ch·ªçn Ch·∫•t</label>
                    <select id="materialSelect"
                        class="w-full p-2 rounded-lg bg-slate-100 dark:bg-slate-700 border-none text-slate-700 dark:text-slate-200 text-sm outline-none focus:ring-2 focus:ring-lab-cyan dark:focus:ring-lab-dark_cyan">
                        <option value="water">N∆∞·ªõc c·∫•t</option>
                        <option value="oil">D·∫ßu th·ª±c v·∫≠t</option>
                        <option value="iron">S·∫Øt</option>
                        <option value="copper">ƒê·ªìng</option>
                        <option value="custom">T·ª± ch·ªçn...</option>
                    </select>
                </div>

                <!-- Empty div to maintain grid if needed, or just let it flow -->
                <div></div>
            </div>

            <!-- Custom Properties (Dynamic) -->
            <div id="customInputs"
                class="mb-4 grid grid-cols-2 gap-4 p-3 bg-slate-50 dark:bg-slate-800/50 rounded-lg hidden">
                <div>
                    <label class="text-xs text-slate-500 mb-1 block">Nhi·ªát ƒë·ªô N√≥ng ch·∫£y (¬∞C)</label>
                    <input type="number" id="inputTm"
                        class="w-full p-1.5 bg-white dark:bg-slate-700 rounded text-sm border border-slate-200 dark:border-slate-600 focus:border-lab-cyan dark:focus:border-lab-dark_cyan outline-none">
                </div>
                <div>
                    <label class="text-xs text-slate-500 mb-1 block">Nhi·ªát ƒë·ªô S√¥i (¬∞C)</label>
                    <input type="number" id="inputTb"
                        class="w-full p-1.5 bg-white dark:bg-slate-700 rounded text-sm border border-slate-200 dark:border-slate-600 focus:border-lab-cyan dark:focus:border-lab-dark_cyan outline-none">
                </div>
            </div>

            <!-- Heating Graph & Controls -->
            <div class="mb-4">
                <canvas id="graphCanvas" width="300" height="150"
                    class="w-full bg-slate-50 dark:bg-slate-800 rounded border border-slate-200 dark:border-slate-700 mb-2"></canvas>
                <div class="flex gap-2">
                    <button id="btnAutoHeat"
                        class="flex-1 py-2 bg-lab-cyan dark:bg-lab-dark_cyan hover:bg-purple-600 dark:hover:bg-sky-600 text-white rounded font-bold transition-colors flex justify-center items-center gap-2">
                        <i data-lucide="play-circle" class="w-5 h-5"></i> Gia nhi·ªát
                    </button>
                    <button id="btnToggleGesture" onclick="toggleGestureControl()"
                        class="w-12 h-[42px] bg-gray-100 hover:bg-gray-200 dark:bg-slate-700 dark:hover:bg-slate-600 text-gray-600 dark:text-slate-300 rounded flex items-center justify-center transition-colors"
                        title="B·∫≠t/T·∫Øt ƒêi·ªÅu khi·ªÉn tay">
                        <i data-lucide="hand" class="w-6 h-6"></i>
                    </button>
                </div>
            </div>

            <!-- Temperature Control -->
            <div class="mb-6">
                <label class="flex justify-between text-sm font-semibold mb-2 text-slate-600 dark:text-slate-300">
                    <span>Nhi·ªát ƒê·ªô (T)</span>
                    <span id="tempDisplay" class="font-mono text-lab-cyan dark:text-lab-dark_cyan text-lg">0¬∞C</span>
                </label>
                <input type="range" id="tempSlider" min="-273" max="3000" value="0" step="1"
                    class="w-full h-3 bg-gradient-to-r from-blue-500 via-purple-500 to-red-500 rounded-lg appearance-none cursor-pointer">
                <div class="flex justify-between mt-2 text-[10px] font-mono text-slate-400">
                    <span id="minTempLabel">-273¬∞C</span>
                    <span id="tmLabel" class="text-blue-400">Tm</span>
                    <span id="tbLabel" class="text-red-400">Tb</span>
                    <span id="maxTempLabel">3000¬∞C</span>
                </div>
            </div>

            <!-- Info Box -->
            <div id="phaseInfo" class="text-xs text-slate-500 dark:text-slate-400 italic">
                Tr·∫°ng th√°i r·∫Øn: C√°c h·∫°t dao ƒë·ªông quanh v·ªã tr√≠ c√¢n b·∫±ng.
            </div>
        </div>
    </div>

    <!-- Webcam & Guide -->
    <video id="webcam-feed" autoplay playsinline muted></video>

    <!-- Big Temp Display (Gesture Mode) -->
    <div id="bigTempDisplay"
        class="fixed top-6 right-28 text-6xl font-bold text-white drop-shadow-lg hidden transition-transform z-40 font-mono pointer-events-none">
        0¬∞C
    </div>

    <div class="gesture-guide">
        <div class="mb-2 font-bold text-cyan-400 flex items-center">
            <span class="status-dot" id="status-dot"></span> ƒêI·ªÄU KHI·ªÇN TAY
        </div>
        <div class="gesture-item">
            <span class="gesture-icon">üëê</span>
            <div>
                <strong>2 Tay</strong>
                <div class="text-xs text-slate-400">K√©o ra/v√†o ƒë·ªÉ Zoom</div>
            </div>
        </div>
        <div class="gesture-item">
            <span class="gesture-icon">üëå</span>
            <div>
                <strong>Ch·ª•m (Ki·ªÉu L)</strong>
                <div class="text-xs text-slate-400">ƒê·ªô m·ªü ng√≥n => Nhi·ªát ƒë·ªô</div>
            </div>
        </div>
        <div class="gesture-item">
            <span class="gesture-icon">üñê</span>
            <div>
                <strong>M·ªü tay</strong>
                <div class="text-xs text-slate-400">Di chuy·ªÉn ƒë·ªÉ Xoay</div>
            </div>
        </div>
        <div id="gesture-debug" class="mt-2 text-xs font-mono text-cyan-200 h-4"></div>
    </div>

    <!-- JS Logic -->
    <script src="./theme.js"></script>
    <script>
        // --- 3D Scene Setup ---
        const container = document.getElementById('simulationCanvas');
        const scene = new THREE.Scene();

        // Camera setup
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 6, 16);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true; // Enable shadows for realism
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxDistance = 40;
        controls.minDistance = 5;
        controls.target.set(0, 2, 0);

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 12, 8);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- Environment ---
        const gridHelper = new THREE.GridHelper(30, 30, 0x1e293b, 0x1e293b);
        scene.add(gridHelper);

        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 30),
            new THREE.MeshStandardMaterial({ color: 0x0f172a, roughness: 0.8, metalness: 0.2 })
        );
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        // Glow Light (for incandescence)
        const glowLight = new THREE.PointLight(0xff4500, 0, 10);
        glowLight.position.set(0, 2, 0);
        glowLight.castShadow = true;
        scene.add(glowLight);

        // FORCE DARK MODE - Strict Enforcement
        const forcedTheme = 'dark';
        document.documentElement.classList.add(forcedTheme);
        localStorage.setItem('theme', forcedTheme); // Optional: force local storage too or just ignore it

        // Override theme.js setTheme to prevent external changes
        window.setTheme = function () { console.log('Theme Locked to Dark'); };

        // 3D Scene Background (Slate-900 / Black)
        scene.background = new THREE.Color(0x0f172a);
        scene.fog = new THREE.Fog(0x0f172a, 10, 50);

        // Floor Setup (Dark)
        plane.material.color.setHex(0x0f172a);
        plane.material.emissive.setHex(0x000000); // No emission to keep it dark

        // Lighting Setup (Standard Dark Mode)
        ambientLight.intensity = 0.6;
        dirLight.intensity = 1.0;

        // Cleanup: remove any legacy theme listeners just in case
        // (No listeners added)



        // --- Macroscopic Objects Setup ---
        const group = new THREE.Group();
        scene.add(group);

        // 1. BEAKER (Glass)
        const glassMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0,
            roughness: 0.1,
            transmission: 0.9, // Glass
            transparent: true,
            opacity: 0.4,
            side: THREE.DoubleSide
        });

        // Simple Cylinder Beaker
        const beakerGeo = new THREE.CylinderGeometry(3.2, 3.2, 5, 32, 1, true);
        const beaker = new THREE.Mesh(beakerGeo, glassMat);
        beaker.position.y = 2.5;
        beaker.castShadow = true;
        group.add(beaker);

        // Beaker bottom
        const beakerBottomGeo = new THREE.CylinderGeometry(3.2, 3.2, 0.2, 32);
        const beakerBottom = new THREE.Mesh(beakerBottomGeo, glassMat);
        beakerBottom.position.y = 0.1;
        beakerBottom.receiveShadow = true;
        group.add(beakerBottom);

        // 2. SUBSTANCE (Solid/Liquid)
        const substanceGroup = new THREE.Group();
        group.add(substanceGroup);

        // Solid Block Geometry (Cube or Rough Chunk)
        const solidGeo = new THREE.BoxGeometry(3, 3, 3);
        const solidMat = new THREE.MeshStandardMaterial({
            color: 0x06b6d4,
            roughness: 0.4,
            metalness: 0.1
        });
        const solidMesh = new THREE.Mesh(solidGeo, solidMat);
        solidMesh.castShadow = true;
        solidMesh.receiveShadow = true;
        solidMesh.position.y = 1.7;
        substanceGroup.add(solidMesh);

        // Liquid Pool Geometry (Cylinder filling the beaker)
        const liquidGeo = new THREE.CylinderGeometry(3.1, 3.1, 1, 32);
        const liquidMat = new THREE.MeshPhysicalMaterial({
            color: 0x06b6d4,
            transmission: 0.6,
            opacity: 0.8,
            transparent: true,
            roughness: 0.1,
            metalness: 0.1
        });
        const liquidMesh = new THREE.Mesh(liquidGeo, liquidMat);
        liquidMesh.position.y = 1; // Initial dummy pos
        liquidMesh.scale.y = 0.01; // Start hidden
        substanceGroup.add(liquidMesh);

        // 3. STEAM / GAS PARTICLES
        const steamCount = 200;
        const steamGeo = new THREE.SphereGeometry(0.2, 8, 8);
        const steamMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3
        });

        const steamParticles = [];
        const steamGroup = new THREE.Group();
        group.add(steamGroup);

        // Pool of steam particles to reuse
        for (let i = 0; i < steamCount; i++) {
            const mesh = new THREE.Mesh(steamGeo, steamMat);
            mesh.visible = false;

            mesh.userData = {
                velocity: new THREE.Vector3(0, 0, 0),
                age: 0,
                life: 100
            };

            steamGroup.add(mesh);
            steamParticles.push(mesh);
        }


        // --- Material Data ---
        // c: Heat Capacity (J/g.K) - approx normalized
        // Lf: Latent Heat Fusion (J/g)
        // Lv: Latent Heat Vaporization (J/g)
        const materials = {
            water: { name: "N∆∞·ªõc", Tm: 0, Tb: 100, colorSolid: 0xa5f3fc, colorLiquid: 0x06b6d4, range: [-20, 150], cS: 2, cL: 4, cG: 2, Lf: 300, Lv: 800, densityRatio: 0.92 }, // Ice (0.92) float on water (1)
            oil: { name: "D·∫ßu", Tm: -20, Tb: 200, colorSolid: 0xfef08a, colorLiquid: 0xeab308, range: [-50, 300], cS: 1.5, cL: 2, cG: 1.5, Lf: 200, Lv: 500, densityRatio: 1.0 },
            iron: { name: "S·∫Øt", Tm: 1538, Tb: 2862, colorSolid: 0x475569, colorLiquid: 0xe64a19, range: [0, 3000], emissive: true, cS: 0.45, cL: 0.6, cG: 0.45, Lf: 270, Lv: 6000, densityRatio: 1.1 }, // Solid denser than liquid
            copper: { name: "ƒê·ªìng", Tm: 1085, Tb: 2562, colorSolid: 0xd97706, colorLiquid: 0xffedd5, range: [0, 2800], emissive: true, cS: 0.38, cL: 0.5, cG: 0.38, Lf: 205, Lv: 4800, densityRatio: 1.1 },
            custom: { name: "T·ª± ch·ªçn", Tm: 0, Tb: 100, colorSolid: 0xd8b4fe, colorLiquid: 0xa855f7, range: [-100, 200], cS: 2, cL: 3, cG: 2, Lf: 300, Lv: 800, densityRatio: 1.0 }
        };

        let currentMat = materials.water;
        let isSimPaused = false;

        // UI References
        const els = {
            matSelect: document.getElementById('materialSelect'),
            customInputs: document.getElementById('customInputs'),
            inputTm: document.getElementById('inputTm'),
            inputTb: document.getElementById('inputTb'),
            tempSlider: document.getElementById('tempSlider'),
            tempDisplay: document.getElementById('tempDisplay'),
            stateLabel: document.getElementById('state-label'),
            phaseInfo: document.getElementById('phaseInfo'),
            tmLabel: document.getElementById('tmLabel'),
            tbLabel: document.getElementById('tbLabel'),
            minTempLabel: document.getElementById('minTempLabel'),
            maxTempLabel: document.getElementById('maxTempLabel'),
            canvas: document.getElementById('graphCanvas'),
            btnHeat: document.getElementById('btnAutoHeat')
        };
        const ctx = els.canvas.getContext('2d');

        let graphData = []; // {t: time, T: temp}
        let isHeating = false;
        let simTime = 0;
        let currentTemp = 0;
        let currentQ = 0; // Accumulated Heat/Latent Progress
        let phaseState = 0; // 0=Solid, 1=Melting, 2=Liquid, 3=Boiling, 4=Gas

        // Visual Progress trackers (0.0 -> 1.0)
        let visualMeltProgress = 0;
        let visualBoilProgress = 0;

        // --- Logic ---
        function updateMaterialUI() {
            const key = els.matSelect.value;
            currentMat = materials[key];

            // Custom mode handling
            if (key === 'custom') {
                els.customInputs.classList.remove('hidden');
                els.inputTm.value = currentMat.Tm;
                els.inputTb.value = currentMat.Tb;
            } else {
                els.customInputs.classList.add('hidden');
            }

            // Update Slider Range
            els.tempSlider.min = currentMat.range[0];
            els.tempSlider.max = currentMat.range[1];
            els.minTempLabel.innerText = currentMat.range[0] + "¬∞C";
            els.maxTempLabel.innerText = currentMat.range[1] + "¬∞C";

            els.tmLabel.innerText = `Tm: ${currentMat.Tm}¬∞C`;
            els.tbLabel.innerText = `Tb: ${currentMat.Tb}¬∞C`;

            // Reset visual props
            updateVisuals();
            stopHeating(); // Reset graph when material changes
            updateSimulationState();
        }

        function stopHeating() {
            isHeating = false;
            simTime = 0;
            graphData = [];
            els.btnHeat.innerHTML = `<i data-lucide="play-circle" class="w-5 h-5"></i> B·∫Øt ƒë·∫ßu Gia nhi·ªát`;
            els.tempSlider.disabled = false;
            // Draw empty graph
            drawGraph();
        }

        function toggleHeating() {
            if (isHeating) {
                stopHeating();
            } else {
                isHeating = true;
                els.btnHeat.innerHTML = `<i data-lucide="stop-circle" class="w-5 h-5"></i> D·ª´ng`;
                els.tempSlider.disabled = true;

                // Initialize Simulation
                currentTemp = currentMat.range[0]; // Start from min
                currentQ = 0; // melting/boiling progress
                els.tempSlider.value = currentTemp;
                graphData = [{ t: 0, T: currentTemp }];

                // Re-init icons
                lucide.createIcons();

                // Reset visual progress
                visualMeltProgress = 0;
                visualBoilProgress = 0;
            }
        }

        function updatePhysics() {
            if (!isHeating) return;

            const dt = 0.5; // time step
            simTime += dt;

            // Heating Rate (Energy per tick)
            const dQ = 5;

            // States:
            // S: Solid Heating -> check if T >= Tm
            // M: Melting (Latent) -> check if Q_accum >= Lf
            // L: Liquid Heating -> check if T >= Tb
            // B: Boiling (Latent) -> check if Q_accum >= Lv
            // G: Gas Heating

            const { Tm, Tb, cS, cL, cG, Lf, Lv } = currentMat;

            if (currentTemp < Tm) {
                // SOLID HEATING
                phaseState = 0;
                currentTemp += dQ / cS * 0.1; // Scale factor for UI speed
                if (currentTemp >= Tm) {
                    currentTemp = Tm;
                    currentQ = 0;
                }
            } else if (Math.abs(currentTemp - Tm) < 0.1 && phaseState <= 1) {
                // MELTING (Plateau)
                phaseState = 1;
                currentQ += dQ;

                // Calculate visual progress based on Heat absorbed
                visualMeltProgress = Math.min(1, currentQ / Lf);

                // Temperature stays at Tm
                if (currentQ >= Lf) {
                    phaseState = 2; // Done melting
                    currentQ = 0;
                    currentTemp += 0.5; // Nudge to enter Liquid phase
                    visualMeltProgress = 1;
                }
            } else if (currentTemp < Tb) {
                // LIQUID HEATING
                phaseState = 2;
                currentTemp += dQ / cL * 0.1;
                if (currentTemp >= Tb) {
                    currentTemp = Tb;
                    currentQ = 0;
                }
            } else if (Math.abs(currentTemp - Tb) < 0.1 && phaseState <= 3) {
                // BOILING (Plateau)
                phaseState = 3;
                currentQ += dQ;

                // Calculate visual progress
                // scaledLv is Lf/4 in original code, matching that logic
                const scaledLv = Lv / 4;
                visualBoilProgress = Math.min(1, currentQ / scaledLv);

                if (currentQ >= scaledLv) { // /4 just to speed up demo, Lv is usually huge
                    phaseState = 4; // Done boiling
                    currentTemp += 0.5; // Nudge
                    visualBoilProgress = 1;
                }
            } else {
                // GAS HEATING
                phaseState = 4;
                currentTemp += dQ / cG * 0.1;
                if (currentTemp > currentMat.range[1]) {
                    // Cap it
                    currentTemp = currentMat.range[1];
                    // stopHeating();
                }
            }

            // Sync to UI
            els.tempSlider.value = currentTemp;
            updateSimulationState(); // This updates the 3D view

            // Record Data
            if (simTime % 2 === 0) { // Optimize points
                graphData.push({ t: simTime, T: currentTemp });
            }
            drawGraph();
        }

        function drawGraph() {
            const w = els.canvas.width;
            const h = els.canvas.height;
            ctx.clearRect(0, 0, w, h);

            // Background / Grid
            ctx.fillStyle = "#f8fafc";
            if (document.documentElement.classList.contains('dark')) ctx.fillStyle = "#1e293b";
            ctx.fillRect(0, 0, w, h);

            ctx.strokeStyle = "#94a3b8";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(30, 10); ctx.lineTo(30, h - 20); // Y axis
            ctx.moveTo(30, h - 20); ctx.lineTo(w - 10, h - 20); // X axis
            ctx.stroke();

            // Labels
            ctx.fillStyle = "#64748b";
            ctx.font = "10px monospace";
            ctx.fillText("T¬∞C", 5, 10);
            ctx.fillText("Time", w - 30, h - 5);

            if (graphData.length < 2) return;

            // Scale
            const maxTime = Math.max(200, graphData[graphData.length - 1].t);
            const minT = currentMat.range[0];
            const maxT = currentMat.range[1];
            const rangeT = maxT - minT;

            // Plot Line
            ctx.strokeStyle = "#06b6d4"; // Cyan
            ctx.lineWidth = 2;
            ctx.beginPath();

            graphData.forEach((p, i) => {
                const x = 30 + (p.t / maxTime) * (w - 40);
                const y = (h - 20) - ((p.T - minT) / rangeT) * (h - 30);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Current Dot
            const last = graphData[graphData.length - 1];
            const cx = 30 + (last.t / maxTime) * (w - 40);
            const cy = (h - 20) - ((last.T - minT) / rangeT) * (h - 30);

            ctx.fillStyle = "#ef4444";
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fill();

            // Text Label
            ctx.fillStyle = "#ef4444";
            ctx.font = "bold 12px sans-serif";
            ctx.fillText(Math.round(last.T) + "¬∞C", cx + 5, cy - 5);
        }

        function updateVisuals() {
            // Update materials colors
            solidMat.color.setHex(currentMat.colorSolid);
            liquidMat.color.setHex(currentMat.colorLiquid);

            // Adjust materials relative to substance type
            if (currentMat.emissive) {
                // Metals: Opaque + Glow potential
                liquidMat.transmission = 0;
                liquidMat.opacity = 1;
                liquidMat.metalness = 0.8;
                liquidMat.roughness = 0.3;

                solidMat.metalness = 0.6;
                solidMat.roughness = 0.7;
            } else {
                // Water/Oil: Transparent/Transmissive
                liquidMat.transmission = 0.6;
                liquidMat.opacity = 0.8;
                liquidMat.metalness = 0.1;
                liquidMat.roughness = 0.1;

                solidMat.metalness = 0.1;
                solidMat.roughness = 0.4;
            }

            // Reset emissive to black initially (animation will override if hot)
            solidMat.emissive.setHex(0x000000);
            liquidMat.emissive.setHex(0x000000);
            solidMat.emissiveIntensity = 0;
            liquidMat.emissiveIntensity = 0;
            glowLight.intensity = 0;
        }

        function updateSimulationState() {
            let temp = parseInt(els.tempSlider.value);
            // Sync custom inputs
            if (els.matSelect.value === 'custom') {
                currentMat.Tm = parseInt(els.inputTm.value) || 0;
                currentMat.Tb = parseInt(els.inputTb.value) || 100;
                els.tmLabel.innerText = `Tm: ${currentMat.Tm}¬∞C`;
                els.tbLabel.innerText = `Tb: ${currentMat.Tb}¬∞C`;
            }

            els.tempDisplay.innerText = temp + "¬∞C";
            // Sync Big Display
            const bigDisp = document.getElementById('bigTempDisplay');
            if (bigDisp) bigDisp.innerText = temp + "¬∞C";

            const { Tm, Tb } = currentMat;

            // Update UI Labels
            if (temp < Tm) {
                els.stateLabel.innerText = "SOLID";
                els.phaseInfo.innerText = "R·∫Øn: Gi·ªØ h√¨nh d·∫°ng c·ªë ƒë·ªãnh.";
                els.stateLabel.className = "text-xs font-mono px-2 py-1 rounded font-bold bg-blue-100 text-blue-600";
            } else if (temp >= Tm && temp < Tb) {
                els.stateLabel.innerText = "LIQUID";
                els.phaseInfo.innerText = "L·ªèng: H√¨nh d·∫°ng theo b√¨nh ch·ª©a, b·ªÅ m·∫∑t ph·∫≥ng.";
                els.stateLabel.className = "text-xs font-mono px-2 py-1 rounded font-bold bg-cyan-100 text-cyan-600";
            } else {
                els.stateLabel.innerText = "GAS";
                els.phaseInfo.innerText = "Kh√≠: Bay h∆°i ra m√¥i tr∆∞·ªùng.";
                els.stateLabel.className = "text-xs font-mono px-2 py-1 rounded font-bold bg-red-100 text-red-600";
            }
        }

        // --- Black Body Radiation Helper ---
        // Returns THREE.Color based on Temp (C)
        function getBlackBodyColor(tempC) {
            const color = new THREE.Color(0x000000);
            if (tempC < 500) return color;

            const t = Math.min(tempC, 3000);

            if (t < 1000) {
                // Red glow (500 -> 1000)
                const i = (t - 500) / 500; // 0 to 1
                color.setRGB(i, 0, 0);
            } else if (t < 2000) {
                // Orange/Yellow (1000 -> 2000)
                const i = (t - 1000) / 1000;
                color.setRGB(1, i * 0.8, 0);
            } else {
                // White (2000 -> 3000+)
                const i = (t - 2000) / 1000;
                color.setRGB(1, 0.8 + i * 0.2, i);
            }
            return color;
        }

        // --- Animation Loop ---
        function animateMacroscopicState(time) {
            let temp = parseInt(els.tempSlider.value);
            const { Tm, Tb } = currentMat;

            // Transition Ranges: +/- 5 degrees
            const meltRange = 10;
            const boilRange = 10;

            // 1. SOLID LOGIC
            // Solid exists fully below Tm. Starts disappearing at Tm. Gone at Tm + meltRange.
            // Melt Progress: 0 (Solid) -> 1 (Melted)
            let meltProgress = 0;

            if (isHeating) {
                // Auto-Heat: Drive by accurate Latent Heat progress
                if (temp < Tm) meltProgress = 0;
                else if (phaseState === 1) meltProgress = visualMeltProgress;
                else if (temp >= Tm && phaseState >= 2) meltProgress = 1;
            } else {
                // Manual: Drive by Temperature smearing
                if (temp < Tm) meltProgress = 0;
                else if (temp > Tm + meltRange) meltProgress = 1;
                else meltProgress = (temp - Tm) / meltRange;
            }

            // Solid Scale/Visibility
            // Scale Solid down to 0 as it melts
            const solidScale = 1 - meltProgress;
            if (solidScale > 0.01) {
                solidMesh.visible = true;
                solidMesh.scale.setScalar(solidScale);
                // Keep it sitting on floor: y = 0.2 + (height/2)*scale
                // Height = 3. 
                solidMesh.position.y = 0.2 + (1.5 * solidScale);
                solidMesh.rotation.y = time * 0.0005; // Gentle rotation for 3D feel
            } else {
                solidMesh.visible = false;
            }

            // 2. LIQUID LOGIC
            // Liquid starts appearing at Tm. Full at Tm + meltRange.
            // Starts disappearing (boiling) at Tb. Gone at Tb + boilRange.

            // Boil Progress: 0 (Not boiling) -> 1 (Fully Boiled/Gas)
            let boilProgress = 0;

            if (isHeating) {
                // Auto-Heat
                if (temp < Tb) boilProgress = 0;
                else if (phaseState === 3) boilProgress = visualBoilProgress;
                else if (temp >= Tb && phaseState === 4) boilProgress = 1;
            } else {
                // Manual
                if (temp < Tb) boilProgress = 0;
                else if (temp > Tb + boilRange) boilProgress = 1;
                else boilProgress = (temp - Tb) / boilRange;
            }

            // Liquid Level
            // Max liquid level = 1 (arbitrary normalized volume) matches solid volume
            // Solid Vol = 3*3*3 = 27.
            // Liquid Cyl Radius = 3.1 => Area ~ 30.19.
            // Height = 27 / 30.19 ~ 0.89.
            // Apply Density Ratio (Vol_liquid = Vol_solid * (Density_solid/Density_liquid))
            // densityRatio = Ds/Dl.

            let liquidAmount = meltProgress * (1 - boilProgress);

            if (liquidAmount > 0.01) {
                liquidMesh.visible = true;

                let ratio = currentMat.densityRatio || 1.0;
                // Exception: Water density ratio is usually listed as Ice/Water ~ 0.92. 
                // If ratio < 1 (like Ice), Liquid Volume < Solid Volume.
                // But physically, 1kg Ice = 1kg Water. V_ice * D_ice = V_water * D_water.
                // V_water = V_ice * (D_ice / D_water).
                // So yes, Base Volume * Ratio is correct.

                const baseLiquidHeight = 0.9;
                const maxH = baseLiquidHeight * ratio;

                const targetHeight = maxH * liquidAmount;

                // Lerp styling
                liquidMesh.scale.y = Math.max(0.01, targetHeight);
                liquidMesh.position.y = 0.2 + (targetHeight / 2); // Sit on bottom
            } else {
                liquidMesh.visible = false;
            }

            // 4. INCANDESCENCE (Glow) LOGIC
            // Realistic Black Body Radiation for metals
            if (currentMat.emissive && temp > 400) {
                const glowColor = getBlackBodyColor(temp);
                // Intensity ramps up with T. 
                // 400C = 0, 1500C = max
                const intensity = Math.min(2, Math.max(0, (temp - 400) / 600));

                // Apply to materials
                solidMat.emissive.copy(glowColor);
                solidMat.emissiveIntensity = intensity;

                liquidMat.emissive.copy(glowColor);
                liquidMat.emissiveIntensity = intensity;

                // Light up the scene
                glowLight.color.copy(glowColor);
                glowLight.intensity = intensity * 1.5;
            } else {
                // Reset if cold
                solidMat.emissive.setHex(0x000000);
                liquidMat.emissive.setHex(0x000000);
                solidMat.emissiveIntensity = 0;
                liquidMat.emissiveIntensity = 0;
                glowLight.intensity = 0;
            }

            // 3. STEAM / GAS LOGIC
            // Steam appears when temp approaches Tb or is higher.
            if (temp > Tb - 20) {
                // Spawn steam
                const spawnRate = Math.max(0.1, (temp - (Tb - 20)) / 50); // More steam as hotter
                if (Math.random() < spawnRate) {
                    spawnSteam();
                }
            }

            updateSteam(time * 0.001);
        }

        function spawnSteam() {
            // Find a dead particle
            const p = steamParticles.find(p => !p.visible);
            if (!p) return;

            p.visible = true;
            // Spawn at random position on liquid surface (or base if empty)
            const r = (Math.random() - 0.5) * 4;
            const theta = Math.random() * Math.PI * 2;
            const radius = Math.random() * 2.5; // Within beaker

            p.position.set(
                Math.cos(theta) * radius,
                liquidMesh.visible ? (liquidMesh.position.y * 2) + 0.2 : 0.5, // Top of liquid
                Math.sin(theta) * radius
            );

            p.userData.age = 0;
            p.userData.life = 100 + Math.random() * 50;
            p.userData.velocity.set(
                (Math.random() - 0.5) * 0.02,
                0.05 + Math.random() * 0.05, // Upward speed
                (Math.random() - 0.5) * 0.02
            );

            // Random scale
            const s = 0.5 + Math.random();
            p.scale.setScalar(s);
        }

        function updateSteam(deltaTime) {
            steamParticles.forEach(p => {
                if (!p.visible) return;

                p.position.add(p.userData.velocity);
                p.userData.age++;

                // Fade out
                const lifeRatio = p.userData.age / p.userData.life;
                p.material.opacity = 0.4 * (1 - lifeRatio);

                // Grow slightly
                p.scale.multiplyScalar(1.005);

                if (p.userData.age >= p.userData.life) {
                    p.visible = false;
                }
            });
        }


        function animate(time = 0) {
            if (isSimPaused) return;
            requestAnimationFrame(animate);
            updatePhysics();
            animateMacroscopicState(time);
            controls.update();
            renderer.render(scene, camera);
        }



        // --- Event Listeners ---
        els.btnHeat.addEventListener('click', toggleHeating);
        els.matSelect.addEventListener('change', updateMaterialUI);
        els.tempSlider.addEventListener('input', updateSimulationState);
        els.inputTm.addEventListener('input', updateSimulationState);
        els.inputTb.addEventListener('input', updateSimulationState);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('theme-changed', (e) => {
            const isDark = e.detail.theme === 'dark';
            if (isDark) {
                scene.background.setHex(0x0f172a);
                scene.fog.color.setHex(0x0f172a);
                gridHelper.material.color.setHex(0x1e293b);
                glassMat.color.setHex(0x88CCFF);
                glassMat.opacity = 0.2;
            } else {
                scene.background.setHex(0xf8fafc);
                scene.fog.color.setHex(0xf8fafc);
                gridHelper.material.color.setHex(0xe2e8f0);
                glassMat.color.setHex(0xffffff);
                glassMat.opacity = 0.4;
            }
        });

        // --- Drag & Toggle Logic ---
        const mainPanel = document.getElementById('mainPanel');
        const panelHeader = document.getElementById('panelHeader');
        const btnShowPanel = document.getElementById('btnShowPanel');
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };

        // Toggle
        window.togglePanel = function (show) {
            if (show) {
                mainPanel.style.display = 'flex';
                btnShowPanel.style.display = 'none';
            } else {
                mainPanel.style.display = 'none';
                btnShowPanel.style.display = 'block';
            }
        }

        // Dragging
        panelHeader.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragOffset.x = e.clientX - mainPanel.offsetLeft;
            dragOffset.y = e.clientY - mainPanel.offsetTop;
            panelHeader.style.cursor = 'grabbing';
        });

        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                e.preventDefault();
                mainPanel.style.left = (e.clientX - dragOffset.x) + 'px';
                mainPanel.style.top = (e.clientY - dragOffset.y) + 'px';
                // Remove right positioning to allow left positioning to take over
                mainPanel.style.right = 'auto';
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            panelHeader.style.cursor = 'move';
        });

        // Init
        updateMaterialUI();
        animate();

        // --- Hand Gesture Logic ---
        const videoElement = document.getElementById('webcam-feed');
        const statusDot = document.getElementById('status-dot');
        const debugText = document.getElementById('gesture-debug');
        const gestureGuide = document.querySelector('.gesture-guide');

        let prevHandPos = { x: 0, y: 0 };
        let handTrackingEnabled = false;
        let cameraUtils = null;
        let hands = null;

        function getGesture(lm) {
            const dist = (i, j) => Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);
            const isFolded = (tip, pip) => dist(tip, 0) < dist(pip, 0);

            // Fingers
            const indexOpen = !isFolded(8, 6);
            const middleOpen = !isFolded(12, 10);
            const ringOpen = !isFolded(16, 14);
            const pinkyOpen = !isFolded(20, 18);

            // Pinch / L-Shape
            const pinchDist = dist(4, 8);
            const isLControl = !isFolded(8, 6) && isFolded(12, 10) && isFolded(16, 14) && isFolded(20, 18);

            const isFist = !indexOpen && !middleOpen && !ringOpen && !pinkyOpen;
            const isOpen = indexOpen && middleOpen && ringOpen && pinkyOpen;

            return { isLControl, isFist, isOpen, pinchDist };
        }

        function onResults(results) {
            if (!handTrackingEnabled) return;

            // Reset status if no hands
            statusDot.classList.remove('active');
            videoElement.classList.remove('active');
            debugText.innerText = "No Hand";

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusDot.classList.add('active');
                videoElement.classList.add('active');

                const numHands = results.multiHandLandmarks.length;

                // --- CASE 1: TWO HANDS -> ZOOM ---
                if (numHands === 2) {
                    const h1 = results.multiHandLandmarks[0][9]; // Middle finger root/tip
                    const h2 = results.multiHandLandmarks[1][9];
                    // Dist between hands
                    const distHands = Math.hypot(h1.x - h2.x, h1.y - h2.y);

                    // Map Dist (0.1 close - 0.8 far) to Camera Dist (30 far - 5 close)
                    // Spread Hands (Large Dist) = Zoom In (Camera Close, Small Radius)
                    // Close Hands (Small Dist) = Zoom Out (Camera Far, Large Radius)

                    const t = (Math.max(0.1, Math.min(0.8, distHands)) - 0.1) / 0.7; // 0..1

                    // t=0 (Close Hands) -> Cam Dist 40
                    // t=1 (Spread Hands) -> Cam Dist 5
                    const targetDist = 40 - (t * 35);

                    const currentDist = camera.position.distanceTo(controls.target);
                    const newDist = currentDist + (targetDist - currentDist) * 0.1; // Smooth

                    const dir = new THREE.Vector3().copy(camera.position).sub(controls.target).normalize();
                    camera.position.copy(controls.target).add(dir.multiplyScalar(newDist));

                    debugText.innerText = `üëê ZOOM 2 HAND: ${(t * 100).toFixed(0)}%`;
                    return; // Priority 1 (Ignore single hand gestures if 2 hands present)
                }

                // --- CASE 2: ONE HAND -> TEMP / ROTATE ---
                const lm = results.multiHandLandmarks[0];
                const g = getGesture(lm);
                const handX = 1 - lm[9].x;
                const handY = lm[9].y;

                // 1. PINCH -> TEMPERATURE
                // Use pinch distance to drive slider
                if (g.isLControl) {
                    const pinchGap = g.pinchDist; // 0.02 to 0.25 typically

                    // Map gap to Temp Range
                    const minP = 0.02;
                    const maxP = 0.20;
                    const percent = Math.max(0, Math.min(1, (pinchGap - minP) / (maxP - minP)));

                    const minT = parseInt(els.tempSlider.min);
                    const maxT = parseInt(els.tempSlider.max);

                    const val = minT + (maxT - minT) * percent;
                    els.tempSlider.value = val;

                    updateSimulationState();
                    debugText.innerText = `üëå TEMP CONTROL: ${val.toFixed(0)}¬∞C`;
                }
                // 2. OPEN -> ROTATE
                else if (g.isOpen) {
                    debugText.innerText = "üîÑ ROTATE";
                    const dx = handX - prevHandPos.x;
                    const dy = handY - prevHandPos.y;
                    if (Math.abs(dx) > 0.002) {
                        const offset = new THREE.Vector3().copy(camera.position).sub(controls.target);
                        const spherical = new THREE.Spherical().setFromVector3(offset);
                        spherical.theta -= dx * 5;
                        spherical.phi -= dy * 5;
                        spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                        const newOffset = new THREE.Vector3().setFromSpherical(spherical);
                        camera.position.copy(controls.target).add(newOffset);
                        camera.lookAt(controls.target);
                    }
                } else {
                    debugText.innerText = "Waiting...";
                }

                prevHandPos = { x: handX, y: handY };
            }
        }

        async function initGesture() {
            hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);

            cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({ image: videoElement }); },
                width: 320, height: 240
            });
        }

        // Toggle Function
        async function toggleGestureControl() {
            handTrackingEnabled = !handTrackingEnabled;
            const btn = document.getElementById('btnToggleGesture');

            if (handTrackingEnabled) {
                // Turn ON
                if (!hands) await initGesture();
                cameraUtils.start();
                videoElement.style.display = 'block';
                gestureGuide.style.display = 'block';
                document.getElementById('bigTempDisplay').classList.remove('hidden');

                // Update Button UI (Active)
                btn.classList.remove('bg-gray-100', 'text-gray-600', 'dark:bg-slate-700', 'dark:text-slate-300');
                btn.classList.add('bg-lab-cyan', 'text-white', 'shadow-lg', 'shadow-cyan-400/50');
                btn.innerHTML = '<i data-lucide="hand" class="w-6 h-6"></i>';
                lucide.createIcons();

                // Auto-hide Control Panel
                togglePanel(false);

            } else {
                // Turn OFF
                if (cameraUtils) cameraUtils.stop();
                videoElement.style.display = 'none';
                gestureGuide.style.display = 'none';
                document.getElementById('bigTempDisplay').classList.add('hidden');

                // Update Button UI (Inactive)
                btn.classList.remove('bg-lab-cyan', 'text-white', 'shadow-lg', 'shadow-cyan-400/50');
                btn.classList.add('bg-gray-100', 'text-gray-600', 'dark:bg-slate-700', 'dark:text-slate-300');
                btn.innerHTML = '<i data-lucide="hand" class="w-6 h-6"></i>';
                lucide.createIcons();
            }
        }

        // Initial State: Hidden
        videoElement.style.display = 'none';
        gestureGuide.style.display = 'none';

        // PAUSE LOGIC
        // isSimPaused moved to top

        window.addEventListener('app-paused', () => {
            isSimPaused = true;
            if (cameraUtils) cameraUtils.stop(); // Stop webcam to save resource
        });

        window.addEventListener('app-resumed', () => {
            isSimPaused = false;
            // if (handTrackingEnabled && cameraUtils) cameraUtils.start(); // Resume webcam if active

            // Restart loop if it was stopped completely, but careful not to double-start
            // Since we return from animate() when paused, the loop breaks. We need to restart it.
            animate();
        });

        // Loop Removed - Duplicate Logic

    </script>
</body>

</html>